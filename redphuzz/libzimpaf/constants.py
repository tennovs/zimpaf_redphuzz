class CoverageReportStatus:
    NO_PATH             = 0     #possibly crash
    KNOWN_PATH          = 1     #path already found previously, no need to create new candidate
    NEW_PATH            = 2     #new path found, create new candidate
    NON_BRANCHING_PATH  = 3     #path with no branch, error logs and function logs might happen

class SoftwareFlaw:
    BUG             = 'BUG'
    VULNERABILITY   = 'VULNERABILITY'

class Vulnerability:
    CODE_EXEC       = 'CODE_EXECUTION'
    OPEN_REDIRECT   = 'OPEN_REDIRECT'
    PATHTRAVS       = 'PATH_TRAVERSAL'
    SQLI            = 'SQL_INJECTION'
    UNSERIALIZE     = 'UNSERIALIZATION'
    XSS             = 'XSS_INJECTION'
    XXE             = 'XXE_INJECTION'

#These are keys used in json written by the C instrumentation to function traces, error log, exception log
#and input parameters comparisons log.
class Key:                          
    FLAW_TYPE           = 'flaw_type'           #value is SoftwareFlaw attribute  
    VULN_TYPE           = 'vuln_type'           #value is Vulnerability attribute 
    FUNCTION_NAME       = 'function_name'       #for function trace, vulnerability, and error/exception
    FILENAME            = 'filename'            #for function trace, vulnerability, and error/exception
    LINENO              = 'lineno'              #for function trace, vulnerability, and error/exception
    QUERY               = 'query'               #for function trace: sqli, vuln func
    RETURN_VALUE        = 'return_value'        #for function trace: sqli, vuln func
    PARAMETERS          = 'parameters'          #for function trace: sqli, bind_execute func
    NUM_PARAMS          = 'num_params'          #for function trace: sqli, bind_execute func
    OBJECT_POINTER      = 'object_pointer'      #for function trace: sqli, bind_execute func
    QUERY_FUNC          = 'query_func'          #for function trace: type of func and in function_traces.py, maybe_safe_sequence[Key.SQLI_SAFESEQ]
    PREPARE_FUNC        = 'prepare_func'        #for function trace: type of func
    SANITATION_FLAG     = 'sanitation'
    NEGATED             = 'negated'             #for function trace: sanitation, whether the result is negated
    BIND_EXECUTE_FUNC   = 'bind_execute_func'   #for function trace: type of func
    PARAMS_QUOTED       = 'params_quoted'       #num of quoted literal params in sql query
    PARAMS_NUMERIC      = 'params_numeric'      #num of numeric literal params in sql query, excl: NULL, TRUE, FALSE
    PARAMS_UNQUOTED     = 'params_unquoted'     #num of unquoted literal params in sql query, numeric, null, bool
    QUERY_OPLINE_TYPE   = 'sink_opline_type'   #is query originated from constant, despite the use of opline the value only 1 (IS_CONST) or 0 otherwise
    COMMAND             = 'command'             #for function trace: code_exec
    COMMAND_OPLINE_TYPE = 'sink_opline_type'
    PATH                = 'path'                #for function trace: pathtravs
    PATH_OPLINE_TYPE    = 'sink_opline_type'    #for function trace: pathtravs, opline type
    DESTINATION_OPLINE_TYPE = 'destination_opline_type'                     
    SERIALIZED_STRING   = 'serialized_string'   #for function trace: unserialize
    SERIALIZED_STRING_OPLINE_TYPE = 'sink_opline_type'
    XML_PAYLOAD         = 'xml_payload'         #for function trace: xxe
    XML_PAYLOAD_OPLINE_TYPE = 'sink_opline_type' 
    SINK_OPLINE_TYPE    = 'sink_opline_type'
    DISABLE             = 'disable'             #for function trace: xxe, libxml_disable_entity_loader  
    OPTIONS             = 'options'             #for function trace: xxe, libxml_disable_entity_loader     
    XSS_PAYLOAD         = 'xss_payload'         #for logic vuln check, not directly involved vuln functions
    STRING              = 'string'              #for function trace: sanitation
    PATTERN             = 'pattern'             #for function trace: sanitation: str_replace, preg_match_preg_replace,strpos
    REPLACEMENT         = 'replacement'         #for function trace: sanitation: preg_replace, str_replace
    ERROR               = 'error'               #for error log to store error message
    ERROR_NO            = 'error_no'            #for error generated by sqli and exceptionhandler in instrumentation
    HTTP_TARGET         = 'http_target'         #representing http target in candidate.http_target retrieved from config
    HTTP_METHOD         = 'http_method'         #representing http method in candidate.http_method retrieved from config
    FIXED_PARAMS        = 'fixed_params'        #generating error report in function: zimpaf_save_vulns_hashes_candidate(...) infuzzer.py
    FUZZ_PARAMS         = 'fuzz_params'         #generating error report in function: zimpaf_save_vulns_hashes_candidate(...) infuzzer.py
    VULN_FUNC_STATUS    = 'vuln_func_status'    #added to loaded function_trace by method: 
                                                #priority_by_matching_vulns_and_vuln_functions in scoring.py
    NUM_FUNC_ITERATIONS     = 'num_func_iterations'      #number of iterations in total for each vuln function
    NUM_PARAMS_ITERATIONS   = "num_params_iterations"
    TABLE               = 'table'               #table name parsed from query and db metadata, see utils.get_tables_columns_to_fuzz and fuzzer.fuzz_sqli_function
    COLUMN              = 'column'              #column name parsed from query and db metadata, see utils.get_tables_columns_to_fuzz and fuzzer.fuzz_sqli_function 
    VALUE               = 'value'
    DATA_TYPE           = 'data_type'           #data type of the column parsed from query and db metadata, see utils.get_tables_columns_to_fuzz and fuzzer.fuzz_sqli_function
    PARAMS_IN_SINK      = 'params_in_sink'      #hold input parameters reach sink
    FUNC_SANIT_REP      = 'func_sanit_rep'      #hold sanitation applied to parameters of vulnerable function
    REQ_PART            = 'req_part'        #part of request: headers, cookies, body params, query params
    PARAM               = 'param'           #the parameter in REQ_PART
    QUOTED              = 'quoted'
    IS_ERROR            = 'is_error'        #whether the error is triggered by the candidate

    CODE_EXEC_FUNCTION      = 'CODE_EXECUTION_FUNCTION' #These naming are extension of Vulnerability class
    PATHTRAVS_FUNCTION      = 'PATH_TRAVERSAL_FUNCTION' #use as keys, e.g. in candidate.vuln_functions = {}
    SQLI_FUNCTION           = 'SQL_INJECTION_FUNCTION'
    UNSERIALIZE_FUNCTION    = 'UNSERIALIZATION_FUNCTION'
    XSS_FUNCTION            = 'XSS_INJECTION_FUNCTION'
    XXE_FUNCTION            = 'XXE_INJECTION_FUNCTION'
    SANITATION_FUNCTION     = 'SANITATION_FUNCTION'     #for sanitation function list {'SANITATION: []}
    DIE_EXIT_FUNCTION       = 'DIE_EXIT_FUNCTION'       #for sanitation function list {'DIE_EXIT: []}
    #for safe sequences
    CODE_EXEC_SAFESEQ       = 'CODE_EXECUTION_SAFESEQ'
    PATHTRAVS_SAFESEQ       = 'PATH_TRAVERSAL_SAFESEQ'
    SQLI_SAFESEQ            = 'SQL_INJECTION_SAFESEQ'
    UNSERIALIZE_SAFESEQ     = 'UNSERIALIZATION_SAFESEQ'
    XSS_SAFESEQ             = 'XSS_INJECTION_SAFESEQ'
    XXE_SAFESEQ             = 'XXE_INJECTION_SAFESEQ'

    #input parameter comparison log: /shared-tmpfs/input_params_comparisons
    OP1_INPUT_PARAM         = 'op1_input_param'
    OP2_INPUT_PARAM	        = 'op2_input_param'
    RESULT                  = 'result'
    OP1_VALUE               = 'op1_value'
    OP1_DATA_TYPE           = 'op1_data_type'
    OP2_VALUE               = 'op2_value'
    OP2_DATA_TYPE	        = 'op2_data_type'
    OPCODE                  = 'opcode'
    OTHER_VAL               = '[OTHER_VAL]'
    OTHER_DATA_TYPE         = '[OTHER_TYPE]'

     #input parameters
    HEADERS                 = 'headers'
    COOKIES                 = 'cookies'
    QUERY_PARAMS            = 'query_params'
    BODY_PARAMS             = 'body_params'
    FILE_PARAMS             = 'files_params'

    #for the checker of the error:
    FLAW_CHECKER            = 'flaw_checker'
    TIME_TO_DISCOVER        = 'time_to_discover'            

    #Monitor is used for optimization, especially to avoid candidates fuzzing potentially vulnerable functions, but
    #are not actually vulnerable. This is possible when the function are called from many parts of the code.
    # E.g. sink is a constant despite originates from variables.
    #these variables are complemented by FUNC_NAME, FILENAME, LINENO
    FUNC_ID                 = 'func_id'
    CANDIDATES_FUZZ         = 'candidates_fuzz' #candidates which are still fuzzing this function
    CANDIDATES_BUGGY        = 'candidates_buggy'#candidates which have identified the function as buggy
    CANDIDATES_VULNERABLE   = 'candidates_vulnerable' #candidates which have identified the function as vulnerable
    CANDIDATES_IN_SAFESEQ   = 'candidates_in_safeseq' #candidates which have identified the function is in safe sequence
    CANDIDATES_UNRESOLVED   = 'candidates_unresolved' #candidates which have finished fuzzing with unresolved status
    NUM_FUZZED              = 'num_fuzzed'  #how many times it has been fuzzed and submitted to web server.
    PREVIOUS_SINK           = 'previous_sink'
    LAST_SINK               = 'last_sink'                                       
    NUM_LAST_SINK_CHANGES   = 'num_last_sink_changes'
    NUM_LAST_SINK_CONSTANT  = 'num_last_sink_constant'


class KeyPayload:
    MALFORMED   = 'malformed'   #malformed input payloads
    WELLFORMED  = 'wellformed'  #well-formed 
    QUOTED      = 'quoted'      #quoted payloads
    UNQUOTED    = 'unquoted'     #numeric payloads
    TAG         = 'tag'
    NON_TAG     = 'non_tag' 

# Zend  Error constants
class Error:
    E_ERROR             = 1 << 0
    E_WARNING           = 1 << 1
    E_PARSE             = 1 << 2
    E_NOTICE            = 1 << 3
    E_CORE_ERROR        = 1 << 4
    E_CORE_WARNING      = 1 << 5
    E_COMPILE_ERROR     = 1 << 6
    E_COMPILE_WARNING   = 1 << 7
    E_USER_ERROR        = 1 << 8
    E_USER_WARNING      = 1 << 9
    E_USER_NOTICE       = 1 << 10
    E_STRICT            = 1 << 11
    E_RECOVERABLE_ERROR = 1 << 12
    E_DEPRECATED        = 1 << 13
    E_USER_DEPRECATED   = 1 << 14
    E_DONT_BAIL         = 1 << 15

FATAL_ERROR_FLAGS = (
    Error.E_ERROR              |   # E_ERROR
    Error.E_PARSE              |   # E_PARSE
    Error.E_CORE_ERROR         |   # E_CORE_ERROR
    Error.E_COMPILE_ERROR      |   # E_COMPILE_ERROR
    Error.E_USER_ERROR         |   # E_USER_ERROR
    Error.E_RECOVERABLE_ERROR      # E_RECOVERABLE_ERROR
)
                    #to check for the path parameter type in include, include_once, require, require_once
class OplineType:   #if constant, then the function is not vulnerable.           
    IS_UNUSED    = 0
    IS_CONST     = 1 << 0
    IS_TMP_VAR   = 1 << 1
    IS_VAR       = 1 << 2
    IS_CV        = 1 << 3

# Define all flags used in any php functions or any part of fuzzer to control behavior
class AllFlags:                     #name is chosen to avoid confusion with keyword Flags in python if any          
    LIBXML_NOENT	    = 1<<1,	    #the same as userland libxml flag to substitute entities */
    LIBXML_DTDLOAD	    = 1<<2, 	#the same as userland libxml flag to load the external subset */
    LIBXML_DTDATTR	    = 1<<3,	    #the same as userland libxml flag to set default DTD attributes */
    LIBXML_DTDVALID	    = 1<<4,	    #the same as userland libxml flag to validate with the DTD */

    XSS_PAYLOAD_TAG     = 1 << 40   #fuzzer xss payload tags to control behaviour
    XSS_PAYLOAD_NON_TAG = 1 << 41   #fuzzer xss payload tags to control behaviour

#execution status flags
class ZendExecStatus:
    FATAL_ERROR_TERMINATION         = 1 << 0    # 0b000001
    DIE_EXIT_TERMINATION            = 1 << 1    # 0b000010
    CONTINUE_WITH_NON_FATAL_ERROR   = 1 << 2    # 0b000100
    CONTINUE_WITH_EXCEPTION         = 1 << 3    # 0b001000
    CONTINUE_NORMAL                 = 1 << 4    # 0b010000

class ThrowableType:
    ERROR       = 1
    EXCEPTION   = 2
       
class APICallTraceStatus:
    NO_TRACE                        = 0
    EXIST_DIE_EXIT_FUNCTION         = 1 << 0    #1
    EXIST_SANITATION_FUNCTION       = 1 << 1    #2
    EXIST_CODE_EXEC_VULN_FUNCTION   = 1 << 2    #4
    EXIST_PATHTRAVS_VULN_FUNCTION   = 1 << 3    #8
    EXIST_SQLI_VULN_FUNCTION        = 1 << 4    #16
    EXIST_UNSERIALIZE_VULN_FUNCTION = 1 << 5    #32
    EXIST_XXE_VULN_FUNCTION         = 1 << 6    #64
    INCOMPLETE                      = 1 << 7    #128 due to errors in processing the trace, e.g. sqlglot parse error
    
class CandidateStatus:
    NOT_FUZZED  = 0     #fuzz hasn't been started
    FUZZED      = 1     #being fuzzed
    DONE        = 4     #done fuzzing

class CandidatePriority:
    NO_PRIORITY = 0     #no priority set, newly generated candidate
    LOW         = 1     #no vulnerable functions exist in the path
    MEDIUM      = 2     #contain sanitation function or has been tried for certain iterations.
    HIGH        = 3     #path contains vulnerable functions that have not been exploited yet
    DONE        = 4     #fuzzing completed for the candidate

class NumIterationsThreshold:
    LOW     = 25
    MEDIUM  = 50
    HIGH    = 100

class FuzzParamsIterations:
    TYPE_VIOLATION      = 3
    DOMAIN_VIOLATION    = 7
    ZERO_OR_EMPTY       = 1
    TYPE_CONFORM        = 2
    SAFE_SEQ            = 1
    TRY_HITTING_SINK    = 4
    NUMERIC_ZERO        = 1
    EMPTY_STRING        = 1
    NUMERIC_ONLY        = 5
    STRING_ONLY         = 5
    DATE_ONLY           = 2
    XSS                 = 3
    RANDOM              = 4
    SANITATION_AWARE    = 3  #more iterations for sanitation aware mutation
    
'''
Class VulnFuncStatus
FUZZED     : vuln function is being fuzzed
IN_SAFESEQ : vuln function is executed in safe seq based on analysis using maybe_safe_sequences dict in functin_trace.py 
             or sanitation function analysis after NumIterationsThreshold.HIGH trials are completed.
EXPLOITED  : already exploited using malformed input (error-based) and malicious-well-formed input, \
MANUAL_ANALYSIS_REQUIRED: very likely to be vulnerable (not in safe seq), but difficult to create a correct mutation             
'''
class VulnFuncStatus:
    FUZZED                  = 1     
    IN_SAFESEQ              = 2
    BUGGY                   = 3 #added     
    VULNERABLE              = 4 #old value: EXPLOITED, old index = 3
    UNRESOLVED              = 5 #old value: FUZZ_ITERATION_DONE, old index = 4
    
'''    
in contrast to safe seq check, we check for unsafe sequence here because main fuzzer know the function is not
in safe seq, but may employs sanitation, but our mutation algorithm not strong enough to uncover the vuln
this usually leads to manual investigation.
class UnsafeSeqCheckSignal: #commented for now, since it is likely to increase false positive
     NO  = 0
     YES = 1
'''

class MutationType:
    DICTIONARY          = 1
    TYPE_VIOLATION      = 2
    DOMAIN_VIOLATION    = 3
    ZERO_OR_EMPTY       = 4
    TYPE_CONFORM        = 5
    TRY_HITTING_SINK    = 6
    NUMERIC_ZERO        = 7
    EMPTY_STRING        = 8
    NUMERIC_ONLY        = 9
    STRING_ONLY         = 10
    DATE_ONLY           = 11
    XSS                 = 12 
    RANDOM              = 13
    SANITATION_AWARE    = 14 
    # 

class VulnCheckType:
    ERR_BASED       = 1 << 0
    FUNC_BASED      = 1 << 1
    LOGIC_BASED     = 1 << 2

class LogicVulnType: 
    XSS             = 1 << 0
    OPEN_REDIRECT   = 1 << 1

class SQLQueryType:
    SELECT  = 1 << 0
    INSERT  = 1 << 1
    UPDATE  = 1 << 2
    DELETE  = 1 << 3
    CREATE  = 1 << 4
    DROP    = 1 << 5

class SanitKey:
    FILTER  = 'filter'
    REPLACE = 'replace'
    ENCODE  = 'encode'
    DECODE  = 'decode'
    ESCAPE  = 'escape'

class MatchingPattern:
    REGEX       = 'regex'
    STRING_LIT  = 'string_lit'

class ZendDataType:
    # Regular data types: Must be in sync with zend_variables.c. */
    IS_UNDEF					= 0
    IS_NULL						= 1
    IS_FALSE					= 2
    IS_TRUE						= 3
    IS_LONG						= 4
    IS_DOUBLE					= 5
    IS_STRING					= 6
    IS_ARRAY					= 7
    IS_OBJECT					= 8
    IS_RESOURCE					= 9
    IS_REFERENCE				= 10
    IS_CONSTANT_AST				= 11 # Constant expressions */

class ZendOpcode:
    # Only takes branch opcodes representing code coverage
    ZEND_IS_IDENTICAL                = 16
    ZEND_IS_NOT_IDENTICAL            = 17
    ZEND_IS_EQUAL                    = 18
    ZEND_IS_NOT_EQUAL                = 19
    ZEND_IS_SMALLER                  = 20
    ZEND_IS_SMALLER_OR_EQUAL         = 21
    ZEND_JMP                         = 42
    ZEND_JMPZ                        = 43
    ZEND_JMPNZ                       = 44
    ZEND_JMPZ_EX                     = 46
    ZEND_JMPNZ_EX                    = 47
    ZEND_CASE                        = 48
    ZEND_CASE_STRICT                 = 196
    ZEND_JMP_NULL                    = 198

class HttpMethod:
    POST    =   'POST'
    PUT     =   'PUT'
    DELETE  =   'DELETE'
    GET     =   'GET'
    OPTIONS =   'OPTIONS'
    TRACE   =   'TRACE'

class CodeBase:
    WEBROOT     = '/var/www/html/'

class FlawChecker:
    ERROR_BASED_CHECKER     = 'error_based_checker'
    FUNCTION_BASED_CHECKER  = 'function_based_checker'  






    
